---
title: 03. 리팩터링 - 코드에서 나는 악취 (18-24)
description: 인프런 병행
date: 2024-10-08 +0900
categories: [Study, Refactoring, Inflearn]
tags: [Team Study]
---


## <b>중재자</b>
- 캡슐화를 통해 내부의 구체적인 정보를 최대한 감출 수 있다는 장점
- 그러나 지나친 캡슐화를 하다보면, 어떤 클래스의 메소드가 대부분 다른 클래스로 메소드 호출을 위임하는 경우가 발생
  - 중재자(캡슐화된 메소드) 를 제거하고 클라이언트가 코드를 직접 사용하도록 코드 개선
- 관련 기술
  - 중재자 제거하기(Remove Middle Man)
  - 함수 인라인(Inline Function)
  - 슈퍼클래스를 위임으로 바꾸기(Replace Superclass With Delegate)
  - 서브클래스를 위임으로 바꾸기(Replace Subclass With Delegate)

### 38. 중재자 제거하기
- “위임 숨기기” 의 반대에 해당하는 리팩토링
- 캡슐화의 정도는 시간과 상황에 따라 바뀔 수 있음

### 39. 슈퍼클래스를 위임으로 바꾸기
- 객체지향에서 "상속"은 기존 기능을 재사용하는 쉬우면서 강력한 방법이지만 때로는 적절하지 않음
- 고민해볼 사항
  - 서브클래스는 슈퍼클래스의 모든 기능을 지원해야 함
  - 서브클래스는 슈퍼클래스 자리를 대체하더라도 잘 동작해야 함(리스코프 치환 원칙)
  - 서브클래스와 슈퍼클래스의 강한 결합으로, 서브클래스는 슈퍼클래스의 변경에 취약함
- 상속을 적용한 이후에, 적절하지 않다는 판단이 들면 리팩토링을 적용

```java
public class Scroll {

    private LocalDate dateLastCleaned;
    private CategoryItem categoryItem;
  
    public Scroll(Integer id, String title, List<String> tags, LocalDate dateLastCleaned) {
      // CategoryItem 를 상속하는 대신 위임을 통해 생성자 직접 호출
      // super(id, title, tags);
        this.categoryItem = new CategoryItem(id, title, tags);
        this.dateLastCleaned = dateLastCleaned;
    }

    public long daysSinceLastCleaning(LocalDate targetDate) {
        return this.dateLastCleaned.until(targetDate, ChronoUnit.DAYS);
    }
}
```

### 40. 서브클래스를 위임으로 바꾸기
- 어떤 객체의 행동이 카테고리에 따라 바뀐다면, 보통 상속을 사용하여 오버라이드
- 하지만 대부분의 프로그래밍 언어에서 상속은 한번만 사용할 수 있음
  - 하나의 객체를 두가지 이상의 카테고리로 분류해야 한다면?
  - <b>위임을 사용하면 얼마든지 여러가지 이유로 다른 객체로 위임할 수 있음</b>
- 슈퍼클래스의 변화가 서브클래스에 영향을 줄 수 있음
  - <b>위임을 사용하면 중간에 인터페이스를 만들어 의존성을 줄일 수 있음</b>
- 위임의 기능
  - 슈퍼/서브 클래스의 강한 결합을 느슨하게 하는 효과
  - 하나 이상의 클래스를 상속하는 것과 유사한 효과
