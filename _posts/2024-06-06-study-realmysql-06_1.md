---
title: 06. 인덱스(1)
description: 인덱스 특징과 B-tree 
date: 2024-06-08 +0900
categories: [Study, Real MySQL 8.0]
tags: [Team Study, RealMySQL, index]
---

> **인덱스의 기대 효과는 데이터 조회 범위를 좁혀 랜덤 I/O 를 최소화하는 것** <br>
> - HDD 는 원판(플래터)를 가진 저장 구조로서 데이터 작업(Read/Write)에 필요한 위치 조회를 위한 플래터 회전 수가 적을 수록 좋음 <br> 
> - 순차 I/O 보다 랜덤 I/O 가 플래터 회전 수가 많고, OLTP 에서의 작업은 대체로 랜덤 I/O 가 많음
>   - (원판 없는 SDD 도 마찬가지)
{: .prompt-info }

## **[인덱스]**
- 일종의 색인
- col (또는 cols) 와 그 값 (주소 또는 pk) 을 key-value 형태로 저장하고 있음
- key 기준으로 정렬
  - insert, update, delete 마다 재정렬이 필요하기때문에 추가적인 비용 발생
- **쓰기 성능을 희생하는 대신 읽기 속도를 높이는 기능**

### [인덱스의 분류]
- 역할에 따라
  - primary key
  - secondary key
- **데이터 저장 알고리즘에 따라**
  - B-tree 알고리즘
  - hash 알고리즘
    - equality 비교시에 유용
    - 주로 메모리 기반 DB 에서 사용
  - 기타 (MySQL 미지원)
    - Merge-Tree, Fractal-Tree
- 데이터 중복 여부에 따라
  - unique index
  - non-unique index
  - 옵티마이저가 실행계획을 분석할 때 중요한 문제

<br>

---
## **[B(Balance)-Tree 인덱스]**
"key 값을 변경하지 않고" "정렬 상태 유지"

### [구조 및 특성]

![인덱스구조](assets/docs/realmysql/ch8_03_1.png){: width="500"} *이미지 출처(RealMySQL8.0)*
- 데이터 파일은 정렬X : Random I/O 가 발생하는 이유

#### 전체 구조
- 루트 노드
  - 최상위 노드
  - 하나만 존재
- 리프 노트
  - 최하위 노드
  - PK 혹은 레코드 저장
- 브랜치 노드
  - 루트와 리프 노드 사이의 모든 노드

#### 리프 노드의 구조
- 루트, 브랜치 노드는 value 로 하위 노드의 페이지 주소를 저장
- 리프 노드의 value 는 데이터 파일에 저장된 레코드 주소 저장
  ![리프구조](assets/docs/realmysql/ch8_03_2.jpeg){: width="500"} *이미지 출처(RealMySQL8.0)*
- 스토리지 엔진에 따라 리프 노드의 value 로 데이터 조회까지의 과정이 다름
  - MyISAM
    - Insert 순으로 데이터가 저장되고 리프에는 ROWID 가 저장
      - ROWID 는 저장 순서 또는 Offset(데이터 파일 내의 위치) 값
    - ROWID 로 데이터 파일에서 바로 조회 가능
  - InnoDB
    - PK 를 ROWID 로 사용
    - 데이터 파일은 PK 가 key 인 B-tree 구조로 데이터를 저장
    - 데이터 파일에서 B-tree 조회를 한번 더 해야함

### [데이터 쓰기 및 읽기]
#### 키 추가하기
- B-tree 내에 적절한 위치 탐색 필요
  - 키 검색 → 리프에 추가
- 리프가 가득 차 있는 경우라면 split
- 비용
  - 레코드 추가 : 인덱스 키 추가 = 1 : 1.5
  
#### 키 삭제
- 키 검색 → 리프 노드 삭제 마킹
- 마킹 후 방치되거나 재사용 가능

#### 키 변경
- 키 검색 → 리프 노드 삭제 마킹 → 키 추가

#### 키 검색
- 트리 탐색의 시간 복잡도는 logN
- InnoDB 는 갭락, 레코드 락으로 인덱스를 잠근 뒤 테이블 레코드를 잠그기 때문에 데이터를 조회할 때 인덱스를 잘 활용하지 않으면 불필요한 레코드를 잠글 수 있으니 주의
- 빠른 검색 성능을 위해 주의할 점
  - equality 검색 혹은 left-most-part, 부등호 검색
  - 값 변형 X (변형된 값은 인덱스 값이 아님)

#### 참고 영상
[(1부) B tree의 개념과 특징, 데이터 삽입이 어떻게 동작하는지를 설명합니다! (DB 인덱스과 관련있는 자료 구조)](https://www.youtube.com/watch?v=bqkcoSm_rCs)

[(2부) B tree 데이터 삭제 동작 방식을 설명합니다 (DB 인덱스과 관련있는 자료 구조)](https://www.youtube.com/watch?v=H_u28u0usjA&t=1816s)

[(3부) B tree가 왜 DB 인덱스(index)로 사용되는지를 설명합니다](https://www.youtube.com/watch?v=liPSnc6Wzfk&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=28)

### [⭐인덱스에 영향을 미치는 요소]
#### 키 값의 크기
- 데이터 조회를 위한 기본 단위 : **블록 또는 페이지**
- 페이지는 여러 쌍의 (인덱스 키, 값) 을 저장하고있는데, 키 길이에 따라 페이지에 저장 가능한 데이터 개수가 달라짐
  - 키가 길수록 페이지의 데이터 개수는 줄어들기 때문에 길어지면 검색결과로 여러 페이지에 접근해야함

#### B-Tree 깊이
- 키의 길이가 길어 페이지에 저장되는 데이터 수가 적어지는 것과 마찬가지로, 트리의 depth 가 깊어질 수 있음
- depth 는 직접 제어할 방법이 없기 때문에 적절한 길이의 key 를 사용하는 것이 좋음

#### Cardinality(선택도, 기수성)
- 인덱스 key 중에서 unique 한 값의 수 (중복도와 반대되는 개념)
- 1만개의 레코드 중 유니크 키 값이 1000개, 10개 일 때
  - 인덱스로 조회되는 값은 10개, 1000개
- 기수성이 클수록 인덱스로 인한 필터링 효과가 큼

#### 조회 할 레코드 건수
- 인덱스 검색 : 테이블 검색 비용 = 4~5 : 1
  - 조회 대상이 테이블 전체 레코드의 20~25% 이상이면 옵티마이저는 인덱스를 사용하지 않음
- 인덱스 힌트 옵션으로 인덱스 사용을 강제하더라도 옵티마이저가 무시할 가능성이 높음
```sql
--force 를 사용하더라도 옵티마이저에 의해 무시될 수 있음
select * from table_name force index index_name; 
select * from table_name use index index_name;
```

<br>

---
## [참고]
### 레코드 저장 순서
- 데이터 파일의 레코드는 insert 순서로 저장됨
  - 그러나 레코드가 삭제되어 빈 공간이 생기면 공간 재활용을 하기도 함
  - 항상 insert 순서로 저장되는 것은 아님
  - 클러스터링 기능은 선택 사항
- InnoDB
  - PK 기준의 클러스터링 인덱스 형태로 데이터 저장
  - insert 순서 아닌 PK 순서로 저장

### 페이지
- 페이지란 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위
- <u>클러스터 인덱스, 세컨더리 인덱스, 테이이블 등은 모두 페이지 단위로 관리</u>
  - 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 페이지를 읽어야 함
  - 그래서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 중요
- 페이지에 저장되는 데이터의 크기가 성능에 미치는 영향
  - 디스크 I/O가 많아질 수 있음
    - 레코드 조회를 위해 여러 페이지를 읽어야 하므로 디스크 I/O 발생 
  - 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음
    - 디스크 I/O를 통해 페이지를 읽어오면 버퍼풀이라는 메모리에 캐싱
    - 개별 데이터의 크기가 커지면 페이지 자체의 크기가 커지면서, 메모리에 캐싱해둘 수 있는 페이지 수가 줄어들게 됨
