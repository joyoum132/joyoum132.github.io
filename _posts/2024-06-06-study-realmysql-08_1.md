---
title: 08. 인덱스(1)
description: 인덱스 특징과 B-tree 
date: 2024-06-08 +0900
categories: [Study, Real MySQL 8.0]
tags: [Team Study, RealMySQL, index]
---

> **인덱스의 기대 효과는 데이터 조회 범위를 좁혀 랜덤 I/O 를 최소화하는 것** <br>
> - HDD 는 원판(플래터)를 가진 저장 구조로서 데이터 작업(Read/Write)에 필요한 위치 조회를 위한 플래터 회전 수가 적을 수록 좋음 <br> 
> - 순차 I/O 보다 랜덤 I/O 가 플래터 회전 수가 많고, OLTP 에서의 작업은 대체로 랜덤 I/O 가 많음
>   - (원판 없는 SDD 도 마찬가지)
{: .prompt-info }

## <b>인덱스란</b>
- 일종의 색인
- col (또는 cols) 와 그 값 (주소 또는 pk) 을 key-value 형태로 저장하고 있음
- key 기준으로 정렬
  - insert, update, delete 마다 재정렬이 필요하기때문에 추가적인 비용 발생
- **쓰기 성능을 희생하는 대신 읽기 속도를 높이는 기능**

## <b>인덱스의 분류</b>
- 역할에 따라
  - primary key
  - secondary key
- **데이터 저장 알고리즘에 따라**
  - B-tree 알고리즘
  - hash 알고리즘
    - equality 비교시에 유용
    - 주로 메모리 기반 DB 에서 사용
  - 기타 (MySQL 미지원)
    - Merge-Tree, Fractal-Tree
- 데이터 중복 여부에 따라
  - unique index
  - non-unique index
  - 옵티마이저가 실행계획을 분석할 때 중요한 문제

<br>

---
## <b>B(Balance)-Tree 인덱스</b>
"key 값을 변경하지 않고" "정렬 상태 유지"

![인덱스구조](assets/docs/realmysql/ch8_03_1.png){: width="500"} 
*이미지 출처(RealMySQL8.0) <br> 데이터 파일은 정렬X : Random I/O 가 발생하는 이유*

[//]: # (### [ 구조 및 특성 ])
### [ 리프 노드의 구조 ]
- 루트, 브랜치 노드는 value 로 하위 노드의 페이지 주소를 저장
- 리프 노드의 value 는 데이터 파일에 저장된 레코드의 PK 혹은 레코드 주소 저장

#### 리프노드의 값으로 데이터 파일의 레코드를 조회하는 방법
![리프구조](assets/docs/realmysql/ch8_03_2.jpeg){: width="500"} 
*이미지 출처(RealMySQL8.0) <br>스토리지 엔진에 따라 리프 노드의 value 로 데이터 조회까지의 과정이 다름*
- MyISAM
  - Insert 순으로 데이터가 저장되고 리프에는 ROWID 가 저장
    - ROWID 는 저장 순서 또는 Offset(데이터 파일 내의 위치) 값
  - ROWID 로 데이터 파일에서 바로 조회 가능
- InnoDB
  - PK 를 ROWID 로 사용
  - 데이터 파일은 PK 가 key 인 B-tree 구조로 데이터를 저장
  - 데이터 파일에서 B-tree 조회를 한번 더 해야함

---

### [ 데이터 쓰기 및 읽기 ]
#### 1. 키 추가
- B-tree 내에 적절한 위치 탐색 필요
  - 키 검색 → 리프에 추가
- 리프가 가득 차 있는 경우라면 split
- 비용
  - 레코드 추가 : 인덱스 키 추가 = 1 : 1.5
  
#### 2. 키 삭제
- 키 검색 → 리프 노드 삭제 마킹
- 마킹 후 방치되거나 재사용 가능

#### 3. 키 변경
- 키 검색 → 리프 노드 삭제 마킹 → 키 추가

#### 4. 키 검색
- 트리 탐색의 시간 복잡도는 logN
- InnoDB 는 갭락, 레코드 락으로 인덱스를 잠근 뒤 테이블 레코드를 잠그기 때문에 데이터를 조회할 때 인덱스를 잘 활용하지 않으면 불필요한 레코드를 잠글 수 있으니 주의
- 빠른 검색 성능을 위해 주의할 점
  - equality 검색 혹은 left-most-part, 부등호 검색
  - 값 변형 X (변형된 값은 인덱스 값이 아님)

#### 참고 영상
[(1부) B tree의 개념과 특징, 데이터 삽입이 어떻게 동작하는지를 설명합니다! (DB 인덱스과 관련있는 자료 구조)](https://www.youtube.com/watch?v=bqkcoSm_rCs)

[(2부) B tree 데이터 삭제 동작 방식을 설명합니다 (DB 인덱스과 관련있는 자료 구조)](https://www.youtube.com/watch?v=H_u28u0usjA&t=1816s)

[(3부) B tree가 왜 DB 인덱스(index)로 사용되는지를 설명합니다](https://www.youtube.com/watch?v=liPSnc6Wzfk&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=28)

---

### [ ⭐인덱스에 영향을 미치는 요소 ]
#### 1. 키 값의 크기
- 데이터 조회를 위한 기본 단위 : **블록 또는 페이지**
- 페이지는 여러 쌍의 (인덱스 키, 값) 을 저장하고있는데, 키 길이에 따라 페이지에 저장 가능한 데이터 개수가 달라짐
  - 키가 길수록 페이지의 데이터 개수는 줄어들기 때문에 길어지면 검색결과로 여러 페이지에 접근해야함

#### 2. B-Tree 깊이
- 키의 길이가 길어 페이지에 저장되는 데이터 수가 적어지는 것과 마찬가지로, 트리의 depth 가 깊어질 수 있음
- depth 는 직접 제어할 방법이 없기 때문에 적절한 길이의 key 를 사용하는 것이 좋음

#### 3. Cardinality(선택도, 기수성)
- 인덱스 key 중에서 unique 한 값의 수 (중복도와 반대되는 개념)
- 1만개의 레코드 중 유니크 키 값이 1000개, 10개 일 때
  - 인덱스로 조회되는 값은 10개, 1000개
- 기수성이 클수록 인덱스로 인한 필터링 효과가 큼

#### 4. 조회 할 레코드 건수
- 인덱스 검색 : 테이블 검색 비용 = 4~5 : 1
  - 조회 대상이 테이블 전체 레코드의 20~25% 이상이면 옵티마이저는 인덱스를 사용하지 않음
- 인덱스 힌트 옵션으로 인덱스 사용을 강제하더라도 옵티마이저가 무시할 가능성이 높음
```sql
--force 를 사용하더라도 옵티마이저에 의해 무시될 수 있음
select * from table_name force index index_name; 
select * from table_name use index index_name;
```

<br>

---

### [ ⭐인덱스를 사용한 스캔 방식 ]
#### 1. 인덱스 레인지 스캔
- 검색 범위가 정해진 경우에 사용하는 방식
- 인덱스를 가장 "잘" 사용하는 경우임
- 검색 과정
  - 조건을 만족하는 값이 저장된 위치를 찾는다 (index seek)
  - 1의 결과를 바탕으로 필요한 만큼 데이터를 조회 (index scan)
  - 2의 결과를 바탕으로 레코드에서 데이터를 읽음 (생략되는 경우 존재. 커버링 인덱스)

#### 2. 인덱스 풀 스캔
- 인덱스 테이블 전체를 스캔
- 사용 예시
  - 쿼리에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우
  - 쿼리에 사용된 컬럼만으로 조건 처리가 가능한 경우
- 인덱스를 아주 효율적으로 사용하는건 아니더라도, 테이블 풀 스캔보다는 성능이 좋음

#### 3. 인덱스 루스 스캔
- 검색 범위 내의 레코드 중 필요한 레코드만 조회
- group by 절이나 min(), max() 같은 집계함수를 사용하는 경우
```sql
-- index: (dept_no, emp_no)
select dept_no, min(emp_no)
    from dept_no
    where dept_no between 'd002' and 'd004'
    group by dept_no;
```

#### 4. 인덱스 스킵 스캔
- 시스템 변수로 ON, OFF 가능
  ```sql
  set optimizer_switch='skip_sacn=OFF';
  ```
- 쿼리의 조건이 인덱스의 첫번째 컬럼이 아닌 경우, 옵티마이저가 첫번째 컬럼의 도메인을 조회해서 조건으로 사용
```sql
-- index : (birth_date)
select gender, birth_date from employees where birth_date > '1992-11-11';
```
- 위 쿼리에서
  - skip_scan=OFF
    - 인덱스 풀스캔 방식으로 접근
  - skip_scan=ON
    - 옵티마이저가 gender 도메인 계산 (M, F)
    - 쿼리 분해하여 range scan 을 사용할 수 있도록 함
      - select gender, birth_date from employees where gender=’m’ and birth_date ≥ ‘1965-02-01’
      - select gender, birth_date from employees where gender=’f’ and birth_date ≥ ‘1965-02-01’
- 장점을 극대화하는 조건
  - 도메인의 개수가 많지 않을 것
  - 쿼리의 결과가 인덱스 내의 컬럼으로 처리 가능할 것 (커버링 인덱스)

<br>

---

### [ 인덱스 스캔 방향 : ASC || DESC ]
- 버전별 복합 정렬 지원 여부
  - MySQL_8.0 >
    - 여러 컬럼을 조합한 인덱스 생성이 가능하고, 각 컬럼마다 다른 정렬 조건을 가질 수 있음
  - MySQL 5.7
    - 혼합 인덱스는 ASC 으로만 정렬
- 인덱스를 오름차순으로 생성했더라도 쿼리가 역순이라면 데이터 조회를 역순으로 함
  - (`무조건 오름차순으로 데이터를 읽고 반환하는 것이 아님!`)
- 그러나 InnoDB 오름차순 데이터에 대한 조회 최적화가 더 잘되어있음 -> 선택 가능하다면 가급적 ASC
- 자주 사용되는 정렬 순서로 인덱스를 사용할 것을 권장

<br>

---

### [ 인덱스의 가용성과 효율성 ]
> 어떤 조건일 때 인덱스를 사용할 수 있는가? 효율성을 높일 수 있는가?
{: .prompt-tip }
> __작업 범위 결정 조건__ : 작업 범위를 결정하는 조건(테이블의 락 범위나 랜덤 I/O 를 좁히기 위한 결정적 조건) <br>
> __필터 조건(체크 조건)__ : 작업 범위를 줄이지는 못하고 실제 조회 여부만을 체크하는 조건
{: .prompt-info }

#### 가용성 : 어떤 조건일 때 인덱스가 무시되는가?
- not (<> , not in, is not null, not between)
- like ‘%string’
  - 왼쪽 값에 기준해서 오른쪽이 정렬되기때문
- 데이터 타입이 다른 비교 (char 형을 int 형과 비교하는 등..)
- 인덱스로 사용한 컬럼의 값을 변경해서 사용하는 경우
- 문자열 데이터의 collation 이 다른 경우
- 스토어드 함수나 다른 연산자로 인덱스 컬럼이 변경된 후 비교된 경우
- not-deterministic 속성의 스토어드 함수가 비교 조건에 사용되는 경우


#### 효율성 : 어떤 조건일 때 효율적인가?
```sql
-- index-A : (dept_no, emp_no)
-- index-B : (emp_no, dept_no)
select * from dept_emp where dept_emp='d001' and emp_no>=10114l 
```
- 위 예시에서
  - index-A
    - 두 컬럼 모두가 작업 범위 결정 조건이므로 레인지 스캔
    - 스캔하는 컬럼이 필요한 컬럼이 되기때문에 높은 효율
  - index-B
    - emp_no 를 작업 범위 결정 조건으로 사용하고 dept_no 는 필터 조건으로 사용
    - 스캔하는 컬럼 중 일부 컬럼만 필요함
- 즉,
  - 작업 범위를 결정하는 조건이 많을수록 쿼리의 처리 성능이 좋음
  - 체크 조건은 쿼리의 처리 성능을 높이지는 않음(걸러주기때문에 랜덤 I/O 는 줄어들 순 있음, 하지만 작업 범위를 좁히지는 못해 오히려 쿼리 실행을 느리게 만들 때가 많음)

<br>

---

## <b> 참고 </b>
### [ 레코드 저장 순서 ]
- 데이터 파일의 레코드는 insert 순서로 저장됨
  - 그러나 레코드가 삭제되어 빈 공간이 생기면 공간 재활용을 하기도 함
  - 항상 insert 순서로 저장되는 것은 아님
  - 클러스터링 기능은 선택 사항
- InnoDB
  - PK 기준의 클러스터링 인덱스 형태로 데이터 저장
  - insert 순서 아닌 PK 순서로 저장

### [ 페이지 ]
- 페이지란 디스크와 메모리(버퍼풀)에 데이터를 읽고 쓰는 최소 작업 단위
- <u>클러스터 인덱스, 세컨더리 인덱스, 테이이블 등은 모두 페이지 단위로 관리</u>
  - 만약 쿼리를 통해 1개의 레코드를 읽고 싶더라도 결국은 하나의 페이지를 읽어야 함
  - 그래서 페이지에 저장되는 개별 데이터의 크기를 최대한 작게 하여 1개의 페이지에 많은 데이터들을 저장할 수 있도록 하는 것이 중요
- 페이지에 저장되는 데이터의 크기가 성능에 미치는 영향
  - 디스크 I/O가 많아질 수 있음
    - 레코드 조회를 위해 여러 페이지를 읽어야 하므로 디스크 I/O 발생 
  - 메모리에 캐싱할 수 있는 페이지의 수가 줄어들 수 있음
    - 디스크 I/O를 통해 페이지를 읽어오면 버퍼풀이라는 메모리에 캐싱
    - 개별 데이터의 크기가 커지면 페이지 자체의 크기가 커지면서, 메모리에 캐싱해둘 수 있는 페이지 수가 줄어들게 됨
