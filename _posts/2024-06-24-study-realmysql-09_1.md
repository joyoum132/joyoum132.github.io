---
title: 09. 옵티마이저와 힌트 - 기본 데이터 처리 방식
description: 
date: 2024-06-24 +0900
categories: [Study, Real MySQL 8.0]
tags: [Team Study, RealMySQL, optimizer]
---

> 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며,
그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업
{: .prompt-info}

## <b> Before Enter </b>
### [ 쿼리 실행 순서 ]
- 쿼리 파싱 (MySQL 서버 / Parser)
  - 쿼리문을 서버가 이해할 수 있는 구조로 파싱 (파스 트리 생성)
  - 문법 오류, 오타 검사 같이 진행
- 쿼리 최적화, 실행 계획 수립 (MySQL 서버 / 옵티마이저)
  - 불필요한 조건 제거, 연산 단순화
  - 테이블 조인 순서 결정
  - 사용 인덱스 결정
  - 데이터의 중간 연산 혹은 임시테이블 생성 여부 결정
- 실행 계획대로 스토리지 엔진에 조회 (MySQL 서버, 스토리지 엔진)

### [ 옵티마이저 종류 ]
- 규칙 기반 최적화
  - 요즘은 사용하지 않음
  - 테이블의 통계자료를(레코드 건수, 선택도 등등) 사용하지 않고 옵티마이저 자체 규칙 우선순위대로 쿼리 실행
  - 동일한 쿼리라면 항상 같은 실행계획을 갖음
- 비용 기반 최적화
  - 쿼리를 수행하는 여러 방법을 계산 후 비용이 적게드는 실행 계획을 사용

<br>

---
## <b> 풀 스캔 → Read Ahead </b>
- <b>리드 어헤드</b>
  - 어떤 영역의 데이터가 앞으로 필요해질 것을 예측해, 요청 전에 디스크로부터 데이터를 읽어 버퍼 풀에 가져다 두는 작업을 의미
- InnoDB 에서는 풀 스캔 할 때 페이지별로 하나씩 읽어오지 않고, 백그라운드 스레드의 리드 어헤드 작업이 자동으로 실행됨
  - MyISAM 은 풀 스캔을 할 때 페이지를 하나씩 읽어옴
- 즉, 풀 스캔 초반에는 포그라운드 스레드에 의해 디스크 읽기 작업을 한다면 <u>특정 시점</u> 부터는 백그라운드에 의해 처리
  - 특정 시점(임계값) 지정 시스템 변수 : `innodb_read_ahead_threshold` 
- 최대 64개의 페이지를 한번에 읽을 수 있음

#### 참고
- 리드 어헤드는 인덱스 풀 스캔, 테이블 풀 스캔에 사용됨
- 인덱스가 있더라도 테이블 풀 스캔을 사용하는 경우는?
  - 테이블의 레코드가 적은 경우 (인덱스를 굳이 사용할 필요가 없다고 판단 / 페이지 1개로 구성될 정도의 개수 일 때)
  - where 또는 on 조건에 사용할만한 인덱스가 없는 경우
  - 조회 할 레코드가 너무 많은 경우 (전체 테이블의 20~25 퍼센트 이상)
```sql
-- index full scan  
select count(*) from reservation;
select * from reservation;
```

## <b> 병렬 처리 <b>
- 하나의 쿼리를 여러 스레드에서 실행한다는 의미의 병렬
- 시스템 변수 : `innodb_parallel_read_threads = N`
  - N 개의 스레드로 처리
- 특정 쿼리를 병렬 처리하기 위한 힌트 옵션은 없음
- where 문이 없는 select * 또는 select count(*) 쿼리만 병렬 처리 가능

## <b> ORDER BY 처리 (Using filesort) <b> 
<b>Best 는 인덱스를 사용하는 것! 그러나 항상 인덱스를 사용할 순 없음 <b>
  - 정렬 기준이 너무 많아 모든 조건을 인덱스로 만들 수 없는 경우
  - group by 혹은 distinct 결과를 정렬하는 경우
  - union 처럼 임시 테이블 결과를 정렬하는 경우
  - 랜덤하게 레코드를 가져오는 경우

### [ 소트 버퍼 ] 
> 정렬 수행을 위해 사용하는 메모리 공간 <br>
> 크기는 가변이지만 최대값 지정 가능 `sort_buffer_size` <br>
> 정렬 용도로만 사용하고, 쿼리 실행 완료 후  즉시 반납
{: .prompt-info}

<b> ❓만약 조회 레코드의 크기가 소트 버퍼보다 크다면? <b> 
- 정렬 할 레코드를 여러 조각으로 나누고 임시 저장을 위해 디스크를 사용☠️
- 순서
  - 레코드 조회 후 소트 버퍼 크기만큼 자르기
  - 소프 버퍼에서 정렬 수행 후 디스크에 저장
  - 소트 버퍼 범위만큼 정렬된 레코드를 전체 병합 (Multi Merge)
- 정렬하는 과정에서 디스크 작업이 발생하기 때문에 성능 저하 유발

<b> ❓소트 버퍼를 크게 할당한다면? <b> 
- 256KB ~ 8MB 가 적당하며, 이보다 크더라도 성능상 큰 개선 효과는 없음
- 소트 버커가 너무 큰 경우 메모리 부족을 유발할 수 있음
  - 이 경우 OOM Killer 가 프로세스를 강제 종료하는데, 사용하는 메모리 크기가 우선순위이므로 MySQL 이 강제종료 1순위
- 다만, 디스크 사용량은 줄일 수 있기 때문에 사용중인 서버의 디스크 성능이 낮다면 소트 버퍼를 크게 잡는 것이 도움이 될 수 있음

### [ 정렬 알고리즘 ]
<b>소트 버퍼에 저장하는 데이터의 종류에 따라 구분<b>

#### 싱글 패스
- 소트버퍼에 정렬 키, 레코드 전체 컬럼을 저장하고 정렬하는 방식
- select 절의 모든 컬럼을 소트 버퍼에 저장하기 때문에 많은 메모리 필요
- 최신 버전에서는 싱글 패스 방식이 일반적이기때문에 select 절에서 필요한 컬럼만 조회할 것!!

#### 멀티 패스
- 소트 버퍼에 정렬 키, 레코드의 프라이머리 키를 저장하고 정렬하는 방식
- 정렬 이후 테이블에 전체 레코드를 조회
- 최신 버전에서는 싱글 패스 사용이 일반적임. 그러나 사용 불가능한 경우 존재
  - 레코드 크기가 max_length_for_sort_data 값 이상일 때
  - select 절에 BLOB, TEXT 타입의 컬럼이 포함되어있을 때

> 정리하자면, 싱글 패스 방식은 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보이며, 투 패스 방식은 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적이라고 볼 수 있다
{: .prompt-tip}

### [ 정렬 처리 ]
- 아래로 갈수록 성능 떨어짐
- 조인을 하게되면 레코드의 크기가 커지기 때문에 정렬을 먼저 하고 조인하는게 성능상 나음

#### 1. 인덱스 사용
- 조건
  - order by 절의 컬럼이 드라이빙 테이블에 속하면서, order by 순서에 맞는 인덱스가 있는 경우
  - where 절에서 첫 번째로 읽는 컬럼이 order by 와 같은 인덱스를 사용하는 경우
  - B-tree 인덱스이면서 Nested Loop 방식의 조인인 경우
- 이 경우 order by 절이 없더라도 있는 것과 같은 결과를 리턴하지만 order by 까지 포함해서 쿼리를 작성하는 것이 좋다 (side effect 예방)
  - 이미 정렬된 레코드와 같은 키의 order by 절이 있다고 한번 더 정렬하지 않음
  - 실행계획에 join buffer 가 있다면 순서가 바뀔 수 있음
  ```sql
  select *
  from employees e, salaries s
  where s.emp_no=e.emp_no
  and e.emp_no between 100002 and 100020
  order by e.emp_no -- 없더라도 결과는 동일
  ```

#### 2. 조인에서 드라이빙 테이블만 정렬
- 조건
  - 드라이빙 테이블의 컬럼만으로 order by 절에 사용
- 드라이빙 테이블 (조인할 때 먼저 조회되는 테이블)만 검색해서 정렬 먼저 하고, 정렬 결과와 드리븐 테이블 조인

#### 3. 조인에서 조인 결과를 임시 테이블에 저장 후 정렬
- 조건
  - 위 두 가지 경우 이외의 상황
    - 예시) 정렬 조건으로 드리븐 테이블의 컬럼을 사용
  - 정렬하기 위해서는 드리븐 테이블의 레코드가 필요하기 때문에 정렬을 먼저 할 수가 없음

#### where 조건에 대한 인덱스 설정과 튜닝을 잘 해도 성능이 느려지는 경우 : 쿼리를 처리하는 방식
- 스트리밍 방식
  - 레코드가 검색될때마다 바로 클라이어느에게 전송
  - 클라이언트는 첫번째 레코드를 빠르게 전달받을 수 있음
  - 쿼리 실행으로 조회되는 결과가 많더라도 클라이언트에게 빠른 응답이 가능
  - 위 세가지 방식 중 인덱스 사용한 데이터 조회시에 스트리밍 방식 사용
- 버퍼링 방식
  - group by, order by 를 사용하면 레코드를 전체 조회한 결과로 연산이 필요하기 때문에 스트리밍 방식 사용이 불가능
  - 그동안 클라이언트는 블록 상태로 대기하기 때문에 (스트리밍 방식 보다) 느리게 결과를 전달받음
  - limit 으로 필요한 레코드를 줄이더라도 큰 영향이 없음

> 인덱스를 사용하는 쿼리는쿼리는 스트리밍 방식으로 결과를 리턴 <br>
> 하지만 JDBC 를 사용한다면 MySQL 이 스트리밍 방식으로 리턴한 결과를 클라이언트에게 보내지 않고 버퍼에 저장해두었다가 모든 결과를 받은 후 전달함 </br>
> </br>
> ✔️이 방식은 전체 처리 시간(Throughput) 이 짧고, JDBC 와 MySQL 간의 통신 횟수를 줄이고(Connection 을 유지한다고 이해) 줄여 전체 처리량이 뛰어남✔️ </br>
> 그러나 만약, 조회 할 데이터가 너무 크다면 버퍼링하는 시간이 길어지기때문에 임시로 스트리밍 방식을 사용하도록 변경이 가능
{: .prompt-tip}

> 인덱스를 사용하지 못하는 (filesort 를 사용하는) 쿼리에서 limit 로 조회 개수를 줄이더라도 도움이 아주 안되는 것은 아님 </br>
> 예를들어, 1만개를 조회하되 order by, limit 10 조건이 있다면 1만개를 전부 조회하지 않고 limit 개수만큼 정렬하고 결과를 리턴함 </br>
> 그 러 나 MySQL 자체적인 정렬 알고리즘(힙 또는 퀵 소트) 으로 쿼리 실행을 위한 작업이 추가되기 때문에 성능에 큰 영향을 주지는 못함
{: .prompt-info}

<br>

---
## <b>GROUP BY 처리 </b>

### [ 인덱스 스캔 사용 (타이트 인덱스 스캔) ]
- 조건
  - 드라이빙 테이블에 속한 컬럼만을 이용해 그루핑
  - 해당 컬럼으로 인덱스가 존재
- 그룹화하는 중간에 데이터 저장을 위한 임시 테이블이 필요할 수 있음
- 실행 계획에 'Using Index group-by', 'Using Temporary', 'Using Filesort' 표시 X
  - ?? 임시테이블을 사용해도?
  - 그럼 뭐라고 뜨나 -> 인덱스 스캔으로 되나보다.

### [ 루스 인덱스 스캔 사용 ]
- 레인지 중 필요한 레코드만 읽는 스캔 방식
- 실행 계획에 'Using index for group-by'
- 옵티마이저가 group by 와 where 을 적절히 섞어 where A and B 와 유사한 방식으로 쿼리를 수행할 수 있도록 함
- 단일 테이블에 대한 group by 에서만 사용
- 프리픽스 인덱스 (컬럼의 앞쪽 일부만으로 생성된 인덱스) 에서는 사용 불가능
- 인덱스 스캔을 사용할 때는 중복도가 낮을수록 유리한 반면, 중복도가 높을수록 유리

### [ 인덱스를 사용하지 않는 경우 ]
- 인덱스를 사용하지 못하는 경우
- 실행 계획에 'Using Temporary' 표시
- 그러나 'Using Filesort' 는 없다!
  - 8.0 이하 버전에서는 group by 키로 정렬까지도 해주었지만 (그래서 filesort 표시) 버전업 이후 묵시적인 정렬을 하지 않기 때문
  - 쿼리에 order by 가 있다면 'Using Filesort' 도 표시

<br>

---

## <b>Distinct 처리</b>
- 집합함수와 사용하는 경우, 아닌 경우가 다르게 동작

### [ 평문에 distinct 사용 ]
- group by 와 동일하게 동작
- 특히 8.0 부터는 group by 절에 대한 자동 정렬 기능이 없기 때문에 내부 동작 방식, 결과가 같음
- 조회하는 모든 컬럼의 조합이 유니크한 결과만을 리턴
  - distinct 바로 뒤의 컬럼만 중복제거하는것이 아님!
```sql
-- 둘의 결과는 같고, 옵티마이저는 괄호를 없애버림
select distinct first_name, last_name from user;
select distinct (first_name), last_name from user;
```

### [ 집합 함수와 distinct 사용 ]
- distinct 키워드 바로 다음 컬럼만 유니크 검사
- 유니크 검사를 위해 임시 테이블 사용 (실행계획에 Using Temporary 가 보이지는 않더라도 임시 테이블을 사용함)

```sql
-- 임시테이블 1개
select count(distinct s.salary) from employees e, salaries s join e.emp_no = s.emp_no where e.emp_no between 1001 and 1100;

-- 임시테이블 2개
select count(distinct s.salary), count(distinct e.last_name)  from employees e, salaries s join e.emp_no = s.emp_no where e.emp_no between 1001 and 1100;

-- 인덱스가 있는 경우 레인지 스캔 or 인덱스 풀 스캔하여 임시 테이블 없이 사용
select count(distinct emp_no) from employees;
select count(distinct emp_no) from dept_emp group by dept_no;
```

<br>

---
## <b> 내부 임시테이블 사용 </b>
- 내부 임시 테이블이란 MySQL 엔진이 쿼리를 수행하는 도중 중간 결과를 저장하기 위해 사용
  - 대표적으로 정렬, 그루핑하는 경우
- 메모리에 생성됐다가 크기가 커지만 디스크로 옮겨짐
- 다른 세션이나 쿼리에서 볼 수 없고, 쿼리 실행 도중에만 존재했다가 사라짐
- `create temporary table` 명령으로 만든 임시 테이블과 다름

### [ 메모리 / 디스크 임시 테이블 ]
<b> 버전마다 사용 엔진이 다름 </b>
- 8.0 이전
  - 메모리 → MEMORY 스토리지 엔진 (단점: 가변 길이 타입 미지원으로 저장 컬럼의 최대 길이 기준으로 컬럼 생성)
    - `temp_table_size`
    - `max_heap_table_size`
  - 디스크 → MyISAM 스토리지 엔진 (단점: 트랜잭션 미지원)
- 8.0 이상
  - 메모리 → TempTable (가변길이 지원)
    - `temptable_max_ram`
  - 디스크 → InnoDB (트랜잭션 지원) 또는 TempTable 의 MMAP 파일 버전
    - `temptable_use_mmax`
    - default 는 TempTable 의 MMAP 파일 버전
    - TempTable 에서 InnoDB 로 전환하는 것 보다 오버헤드가 적음

### [ 임시 테이블이 필요한 쿼리 ]
- order by, group by 에 명시된 컬럼이 다른 경우
- order by, group by 에 명시된 컬럼이 조인 순서상 첫 번째 테이블이 아닌 경우
- distinct 와 order by 가 동시에 쿼리에 존재하는 경우 또는 distinct 가 인덱스로 처리되지 못하는 경우
- union 이나 union distinct 가 사용된 쿼리 (select_type 컬럼이 union_result 인 경우)
- 쿼리의 실행 계획에서 select_type 이 drived 인 쿼리

### [ 임시 테이블이 디스크에 바로 생성되는 경우 ]
- union 이나 union all 에서 select 되는 컬럼 중에서 길이가 512 바이트 이상인 크기의 칼럼이 있는 경우
- group by 나 distinct 컬럼에서 512 바이트 이상인 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 tmp_table_size 또는 max_heap_table_size 시스템 변수보다 크거나 temptable_max_ram 사이즈보다 큰 경우

### [ 임시 테이블 관련 상태 변수 ]
- 임시 테이블을 사용하더라도 'Using Temporary' 가 있을 수도, 없을 수도 있음
- 있더라도 메모리/디스크 어디서 처리됐는지 알 수 없고
- 몇개의 임시 테이블이 있었는지 알 수 없음
```sql
-- 다른 쿼리 결과와 섞이지 않도록 세션 초기화
flush status;
      
-- 임시 테이블 관련 정보를 확인할 쿼리 실행
select .... ;

-- 임시 테이블 관련 상태 조회
show session status like 'created_tmp%';
```
- created_tmp_tables : 내부 임시 테이블 개수 누적 값(메모리, 디스크 구분 X)
- created_tmp_disk_tables : 디스크 내부 임시 테이블 개수 누적
