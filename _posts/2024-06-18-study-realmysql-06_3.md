---
title: 06. 인덱스(3)
description: MySQL 의 기타 인덱스와 알고리즘
date: 2024-06-18 +0900
categories: [Study, Real MySQL 8.0]
tags: [Team Study, RealMySQL, index]
---
## <b>멀티 벨류 인덱스</b>
- 레코드가 여러개의 키를 가질 때 사용할 수 있는 인덱스
- 일반적으로 원자성이라는 특징 때문에 하나의 레코드는 하나의 인덱스 키 값을 갖지만 Json 을 지원하면서 하나 이상의 키 값을 가질 수 있게 되었음
- MySQL 8.0 부터는 Json 컬럼에 대한 인덱스를 지원 (이전에는 Json 컬럼만 지원)
- 주의할 점은
  - 멀티 벨류 컬럼에 대한 인덱스 생성 후
  - `MEMBER OF()`, `JSON_CONTAINS()`, `JSON_OVERLAPS()` 함수를 이용해 검색해야 인덱스를 사용하게 됨

<br>

---
## <b>클러스터링 인덱스(클러스터링 테이블)</b>
- PK 로 인덱스 테이블을 구성하는 것
- InnoDB 에서만 지원
- PK 위치가 레코드 저장 위치를 지정 → PK 에 대한 의존도가 높음
- 세컨더리 인덱스와의 차이점은 리프 노드에 실제 데이터를 저장하고 있다는 것!

#### Q. InnoDB 테이블에 Primary Key 가 없다면?
- (0 순위는 명시적으로 지정한 PK 를 클러스터링 키로 사용하는 것) 
- 유니크 인덱스 중 Not-Null & Unique 인 인덱스 중 첫번째를 클러스터링 키로 선택 
- 유니크 값을 갖는 임의의 컬럼을 생성해서 클러스터링 키로 선택 (외부에서 조회할 수 없는 값)

#### Q. InnoDB 테이블의 세컨더리 인덱스의 리프 노드에 레코드 주소를 저장한다면?
- 다른 스토리지 엔진의 경우 최초 레코드 저장 이후 프라이머리 키, 인덱스 키가 바뀌더라도 주소가 변경되지 않음(주소: ROWID)
- 그러나 InnoDB 는 정렬 상태를 유지해야하기때문에 프라이머리 키, 인덱스 키가 바뀌면 주소도 바뀌어야 함
- InnoDB 의 리프 노드에 PK/인덱스K 가 아닌 주솟값이 저장된다면 값이 변경될때마다 레코드 주소 변경 + 테이블의 인덱스에 저장된 모든 주소를 변경해야 함
  - 이런 오버헤드를 줄이기 위해 리프 노드에는 주솟값 대신 PK 가 저장됨
- 키가 바뀌면 관련 있는 인덱스 리프의 키를 변경해야하니까 같은거 아닌가..

### [ 장/단점 ]
- <b>장점</b>
  - PK 검색 성능이 우수
  - 세컨더리 인덱스의 리프 노드에 PK 를 저장하기 때문에 커버링 인덱스 사용률이 높아짐 
- <b>단점</b>
  - 세컨더리 인덱스의 리프에는 PK 가 저장되기 때문에 클러스터링 키가 큰 경우 전체적으로 인덱스 크기 커짐
  - 세컨더리 인덱스 검색 후 다시 PK 인덱스를 검색해야 하므로 처리 성능이 느림
  - insert할 때 PK 에 의해 레코드 저장 위치가 결정되기 때문에 처리 성능이 느림
  - PK를 update/delete 할 때에도 위치검색이 선행되어야 하기 때문에 성능이 느림

### [ 사용 주의 사항 ]
- PK 키의 크기
  - 전체적으로 인덱스 크기가 커질 수 있음
- PK 는 Auto-Increment 대신 업무적(비즈니스적) 컬럼으로 사용하는 것 권장
  - PK 성능이 좋기때문에 검색에 빈번하게 사용되거나 서비스적으로 유의미한 컬럼을 사용할 것
- PK 는 반드시 명시하고, 사용할 컬럼이 없다면 Auto-Increment 라도 사용할 것
  - PK가 없어 임의의 컬럼을 사용하게될 때 그 값은 Auto-Increment 형태와 유사
  - 차라리 조회가 가능한 Auto-Increment 를 명시적으로 사용하자
- 복합키를 사용하고 세컨더리 인덱스도 사용해야 한다면 인조 식별자를 사용할 것
  - 이 경우 전체적으로 인덱스가 커질 수 있기때문에 PK 를 대체하는 인위적인 PK(인조식별자) 를 사용하는 것이 성능상 유리함

<br>

---
## <b>유니크 인덱스</b>
- MySQL 에서는 유니크 제약조건을 생성하는 경우 인덱스 생성 필수
- null 값을 허용하지만 null 은 특정한 값을 의미하는것이 아니기 때문에 하나 이상의 값이 저장될 수 있음

### [ 세컨더리 인덱스와 비교 ]
- 인덱스 구조는 동일

#### 읽기
- 유니크 인덱스를 사용하게 되면 레코드를 조회할 때 limit 1 처럼 동작해서 일반 인덱스보다 성능이 좋을 것이라고 오해하지만
- 인덱스 스캔은 CPU 에서 처리하는 영역으로
- 디스크 조회(랜덤 I/O) 횟수는 동일하기 때문에 큰 차이 없음

#### 쓰기
- 유니크 인덱스는 데이터의 존재 여부를 확인하는 작업이 추가되므로 일반 세컨더리 인덱스보다 느림
- MySQL 에서 중복 체크 시 읽기 잠금, 인덱스 키 추가 시 쓰기 잠금 발생 → 데드락 유발
- 중복 체크를 하는 경우 체인지 버퍼를 사용할 수 없음 → 쓰기 지연이 불가능하여 변경 작업 속도 느림
  - 인덱스 변경 작업을 미루기 위해 저장하는 임시 버퍼, 중복 체크가 필요하기때문에 체인지 버퍼의 내용을 디스크에 반영한 뒤에 중복 체크, 변경 작업 함

### [ 주의사항 ]
- 한 컬럼에 대한 유니크 제약조건과 인덱스는 같은 역할을 하므로 중복되지 않도록 주의
- 프라이머리 키에 유니크 인덱스를 생성하는 것도 같은 역할이므로 중복되지 않도록 주의

### [ 결론 ]
- 유니크 인덱스가 성능상 눈에 띄는 이점이 있는 것은 아님
- 유일성이 중요하다면 유니크 인덱스를 생성하고
- 아니라면 <u>유니크하지 않은</u> 일반 세컨더리 인덱스를 생성하자

<br>

---
## <b>외래키</b>
- InnoDB 스토리지 엔진에서만 지원
- <b>테이블 변경(쓰기 잠금)이 발생하는 경우 잠금 대기 발생</b>
- <b>외래키로 사용중인 컬럼 변경이 발생하는 경우 잠금 대기 발생</b>

### [ 잠금으로 인한 대기 발생 시나리오 ]
- 자식 테이블에서 발생
  - 부모 테이블에서 컬럼 변경 진행 (쓰기 잠금 획득) → 자식 테이블에서 외래키 변경 진행
    - 자식 테이블이 외래키가 아닌 다른 컬럼의 값을 변경하는 경우라면 대기 없이 바로 수정
- 부모 테이블에서 발생
  - 자식 테이블에서 컬럼 변경 진행 (쓰기 잠금 획득) → 부모 테이블에서 자식이 참조하는 컬럼에 대한 변경 진행
    - CASCADE 작업을 위해 자식 테이블의 트랜잭션 종료를 대기

### [ 물리적인 외래키 사용시 유의할 점 ]
- 잠금이 다른 테이블에 영향을 주기때문에 전체적인 쿼리 성능, 동시 처리 성능에 영향을 줄 수 있음
  - 쓰기 잠금 및 대기 : 외래키 컬럼 수정시 부모 또는 자식 테이블의 트랜잭션에 영향을 받음
  - 읽기 잠금 및 대기 : 자식 테이블에서 데이터 추가시 부모 테이블에 존재하는지 체크를 위한 잠금 획득

