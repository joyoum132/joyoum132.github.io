---
title: 06. 인덱스(3)
description: MySQL 의 기타 인덱스와 알고리즘
date: 2024-06-18 +0900
categories: [Study, Real MySQL 8.0]
tags: [Team Study, RealMySQL, index]
---
## <b>멀티 벨류 인덱스</b>
- 레코드가 여러개의 키를 가질 때 사용할 수 있는 인덱스
- 일반적으로 원자성이라는 특징 때문에 하나의 레코드는 하나의 인덱스 키 값을 갖지만 Json 을 지원하면서 하나 이상의 키 값을 가질 수 있게 되었음
- MySQL 8.0 부터는 Json 컬럼에 대한 인덱스를 지원 (이전에는 Json 컬럼만 지원)
- 주의할 점은
  - 멀티 벨류 컬럼에 대한 인덱스 생성 후
  - `MEMBER OF()`, `JSON_CONTAINS()`, `JSON_OVERLAPS()` 함수를 이용해 검색해야 인덱스를 사용하게 됨

<br>

---
## <b>클러스터링 인덱스(클러스터링 테이블)</b>
- PK 로 인덱스 테이블을 구성하는 것
- InnoDB 에서만 지원
- PK 위치가 레코드 저장 위치를 지정 → PK 에 대한 의존도가 높음
- 세컨더리 인덱스와의 차이점은 리프 노드에 실제 데이터를 저장하고 있다는 것!

#### Q. InnoDB 테이블에 Primary Key 가 없다면?
- (0 순위는 명시적으로 지정한 PK 를 클러스터링 키로 사용하는 것) 
- 유니크 인덱스 중 Not-Null & Unique 인 인덱스 중 첫번째를 클러스터링 키로 선택 
- 유니크 값을 갖는 임의의 컬럼을 생성해서 클러스터링 키로 선택 (외부에서 조회할 수 없는 값)

#### Q. InnoDB 테이블의 세컨더리 인덱스의 리프 노드에 레코드 주소를 저장한다면?
- 다른 스토리지 엔진의 경우 최초 레코드 저장 이후 프라이머리 키, 인덱스 키가 바뀌더라도 주소가 변경되지 않음(주소: ROWID)
- 그러나 InnoDB 는 정렬 상태를 유지해야하기때문에 프라이머리 키, 인덱스 키가 바뀌면 주소도 바뀌어야 함
- InnoDB 의 리프 노드에 PK/인덱스K 가 아닌 주솟값이 저장된다면 값이 변경될때마다 레코드 주소 변경 + 테이블의 인덱스에 저장된 모든 주소를 변경해야 함
  - 이런 오버헤드를 줄이기 위해 리프 노드에는 주솟값 대신 PK 가 저장됨
- 키가 바뀌면 관련 있는 인덱스 리프의 키를 변경해야하니까 같은거 아닌가..

### [ 장/단점 ]
- <b>장점</b>
  - PK 검색 성능이 우수
  - 세컨더리 인덱스의 리프 노드에 PK 를 저장하기 때문에 커버링 인덱스 사용률이 높아짐 
- <b>단점</b>
  - 세컨더리 인덱스의 리프에는 PK 가 저장되기 때문에 클러스터링 키가 큰 경우 전체적으로 인덱스 크기 커짐
  - 세컨더리 인덱스 검색 후 다시 PK 인덱스를 검색해야 하므로 처리 성능이 느림
  - insert할 때 PK 에 의해 레코드 저장 위치가 결정되기 때문에 처리 성능이 느림
  - PK를 update/delete 할 때에도 위치검색이 선행되어야 하기 때문에 성능이 느림

### [ 사용 주의 사항 ]
- PK 키의 크기
  - 전체적으로 인덱스 크기가 커질 수 있음
- PK 는 Auto-Increment 대신 업무적(비즈니스적) 컬럼으로 사용하는 것 권장
  - PK 성능이 좋기때문에 검색에 빈번하게 사용되거나 서비스적으로 유의미한 컬럼을 사용할 것
- PK 는 반드시 명시하고, 사용할 컬럼이 없다면 Auto-Increment 라도 사용할 것
  - PK가 없어 임의의 컬럼을 사용하게될 때 그 값은 Auto-Increment 형태와 유사
  - 차라리 조회가 가능한 Auto-Increment 를 명시적으로 사용하자
- 복합키를 사용하고 세컨더리 인덱스도 사용해야 한다면 인조 식별자를 사용할 것
  - 이 경우 전체적으로 인덱스가 커질 수 있기때문에 PK 를 대체하는 인위적인 PK(인조식별자) 를 사용하는 것이 성능상 유리함
